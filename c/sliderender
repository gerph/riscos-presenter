/*******************************************************************
 * File:        sliderender
 * Purpose:     Render the slides
 * Author:      Gerph
 * Date:        18 Sep 2020
 ******************************************************************/


#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include "swis.h"

#include "gcontext.h"
#include "textblock.h"
#include "fontfamily.h"

#include "slidedeck.h"
#include "slidedeck_debug.h"
#include "sliderender.h"

/* Define this to debug this file */
//#undef DEBUG
//#define DEBUG

#ifdef DEBUG
#define dprintf if (1) _swix(0x104,0), printf
#else
#define dprintf if (0) _swix(0x104,0), printf
#endif


#define MAXHEADING 3


typedef struct fontdefaults_ {
    char *name;
    int xsize, ysize;
} fontdefault_t;

fontdefault_t fontdefault_body = {
    "HirukoPro.Book", (12*16), (12*16)
};
fontdefault_t fontdefault_code = {
    "FairfaxSMHD.Medium", (12*16), (12*16)
};
fontdefault_t fontdefault_headings[MAXHEADING] = {
    {"Optima.Bold", (22*16), (22*16)},
    {"Optima.Bold", (18*16), (18*16)},
    {"Optima.Regular", (16*16), (16*16)},
};


/* Rendering context for a slide */
struct sliderender_s {
    slidedeck_t *deck;
    slide_t *slide;
    int slidenumber;

    bbox_t region;

    unsigned long colour_bg;
    unsigned long colour_fg;

    int in_heading; /* Which heading we're in, or -1 if we're not in a heading */

    fontfamily_t family_heading[MAXHEADING];
    fontfamily_t family_body;
    fontfamily_t family_code;

    font_t font_body; /* A reference to the base font in family_body */

    textblock_t textblock;
    int pass;

    bounds_t em;
};


/*************************************************** Gerph *********
 Function:      sliderender_block
 Description:   Render a single block from a slide
 Parameters:    render-> the render to use
                block-> the block we're rendering
 Returns:       none
 ******************************************************************/
static void sliderender_block(sliderender_t *render,
                              slideblock_t *block)
{
    unsigned long flags = (render->pass==0) ? 0 : TBADD_PAINT;
    switch (block->blocktype)
    {
        case sbt_heading:
            dprintf("  Heading %i\n", block->index);
            render->in_heading = block->index - 1;
            break;

        case sbt_list:
            if (block->index == -1)
            {
                dprintf("  List unordered\n");
            }
            else
            {
                dprintf("  List ordered, next index %i\n", block->index);
            }

            /* Entering and leaving a list should insert somee extra space */
            textblock_gap(render->textblock, render->em.height / 2, NULL);

            /* Set up the indentation for the block */
            {
                int indent = render->em.width / 2;
                if (block->parent)
                    indent += render->em.width * 1.5;
                textblock_inset(render->textblock, indent, indent);
            }
            break;

        case sbt_item:
            if (block->index == -1)
            {
                dprintf("  Item unordered\n");
                textblock_inset(render->textblock, render->em.width * .5, render->em.width * .5);
                textblock_add(render->textblock,
                              render->font_body,
                              // "\xb7",        // Latin-1 encoding of middot
                              "\xe2\x80\xa2",   // UTF-8 encoding of bullet
                              render->colour_bg, render->colour_fg,
                              flags);
                textblock_inset(render->textblock, render->em.width, render->em.width);
            }
            else
            {
                char buf[4];
                sprintf(buf, "%i.", block->index + 1);
                dprintf("  Item ordered, index %i\n", block->index);
                textblock_add(render->textblock,
                              render->font_body,
                              buf,
                              render->colour_bg, render->colour_fg,
                              flags);
                // Indent for the spans
                textblock_inset(render->textblock, render->em.width * 1.5, render->em.width * 1.5);
            }

            break;
    }

    /* This is a new horizontal block, so it has its own sizing */
    textblock_clear(render->textblock, TBCLEAR_SIZING);

    if (block->blocks)
    {
        /* Has nested blocks */
        slideblock_t *nest;

        for (nest = block->blocks; nest; nest=nest->next)
        {
            sliderender_block(render, nest);
        }
    }
    if (block->spans)
    {
        slidespan_t *span;
        for (span = block->spans; span; span=span->next)
        {
            int fontstyle = 0;
            int fontflags = flags;
            fontfamily_t family;
            font_t font;
            if (span->render.bold)
                fontstyle |= FONTFAMILY_STYLE_BOLD;
            if (span->render.italic)
                fontstyle |= FONTFAMILY_STYLE_SLANT;
            if (span->render.underline)
                fontflags |= TBADD_UNDERLINE;
            if (span->render.del)
                fontflags |= TBADD_STRIKETHROUGH;

            if (span->render.code)
                family = render->family_code;
            else if (render->in_heading != -1)
                family = render->family_heading[render->in_heading];
            else
                family = render->family_body;

            dprintf("Rendering with family %p\n", family);
            font = fontfamily_get_font(family, fontstyle);

            dprintf("Text: (style=%i) %s\n", fontstyle, span->text);
            textblock_add(render->textblock,
                          font,
                          span->text,
                          render->colour_bg, render->colour_fg,
                          fontflags);
        }

        textblock_clear(render->textblock, TBCLEAR_TEXTNEWLINE);
    }

    switch (block->blocktype)
    {
        case sbt_list:
            /* We're now leaving the list */
            {
                int indent = render->em.width / 2;
                if (block->parent)
                    indent += render->em.width * 1.5;
                textblock_inset(render->textblock, -indent, -indent);
            }

            /* Entering and leaving a list should insert somee extra space */
            textblock_gap(render->textblock, render->em.height / 2, NULL);
            break;

        case sbt_item:
            // Restore the indent as we leave the item
            textblock_inset(render->textblock, -render->em.width * 1.5, -render->em.width * 1.5);
            break;
    }

    /* We're not in a heading any more */
    render->in_heading = -1;
}


/*************************************************** Gerph *********
 Function:      sliderender_prepare_font
 Description:   Set up a font family for the current slide
 Parameters:    render-> the render to work with
                keyname-> the name of this family to set up from the slide properties
                fontdefault-> the defaults to use for this family
 Returns:       fontfamily_t for this font, or NULL if none could be assigned
 ******************************************************************/
static fontfamily_t sliderender_prepare_font(sliderender_t *render,
                                             const char *keyname,
                                             fontdefault_t *fontdefault)
{
    /* FIXME: Use the properties from the slide */
    const char *font = fontdefault->name;
    int xsize = fontdefault->xsize;
    int ysize = fontdefault->ysize;
    fontfamily_t family;

    dprintf("Preparing family '%s' with font '%s'\n", keyname, font);
    family = fontfamily_create(font, xsize, ysize);
    if (family == NULL)
    {
        dprintf("Cannot create font family for %s\n", keyname);
        return NULL;
    }
    if (fontfamily_populate(family))
    {
        dprintf("Cannot populate font family for %s\n", keyname);
        return NULL;
    }

    return family;
}


/*************************************************** Gerph *********
 Function:      sliderender_clear
 Description:   Free all the transient and cached details for this render
 Parameters:    render-> the render to clear
 Returns:       none
 ******************************************************************/
static void sliderender_clear(sliderender_t *render)
{
    int n;

    fontfamily_destroy(render->family_body);
    render->family_body = NULL;
    fontfamily_destroy(render->family_code);
    render->family_code = NULL;

    for (n=0; n<MAXHEADING; n++)
    {
        fontfamily_destroy(render->family_heading[n]);
        render->family_heading[n] = NULL;
    }
    textblock_destroy(render->textblock);
    render->textblock = NULL;
}


/*************************************************** Gerph *********
 Function:      sliderender_destroy
 Description:   Destroy the block, freeing all memory associated with it
 Parameters:    render-> the render to free
 Returns:       none
 ******************************************************************/
void sliderender_destroy(sliderender_t *render)
{
    if (render == NULL)
        return;

    sliderender_clear(render);
    free(render);
}


/*************************************************** Gerph *********
 Function:      sliderender_create
 Description:   Create a structure to manage the rendering of the
                slides
 Parameters:    deck-> the slide deck to render
                slidenumber = the number of the slide we're rendering
                region-> the bounds of the region to prepare for
 Returns:       pointer to sliderender_t, or NULL if failed
 ******************************************************************/
sliderender_t *sliderender_create(slidedeck_t *deck, int slidenumber, bbox_t *region)
{
    sliderender_t *render = calloc(1, sizeof(*render));
    if (render == NULL)
        return NULL;

    render->deck = deck;
    render->slidenumber = -1;
    if (region)
    {
        render->region = *region;
    }
    else
    {
        /* If no region was specified, give it a default size; they can change it later */
        render->region.x0 = 0;
        render->region.y0 = 0;
        render->region.x1 = 640;
        render->region.y1 = 480;
    }

    sliderender_set_slide(render, slidenumber);

    return render;
}


/*************************************************** Gerph *********
 Function:      sliderender_set_slide
 Description:   Select the slide number that we are going to render
 Parameters:    render-> the render block
                slidenumber = number of the slide we're going to show
 Returns:       1 if failed, 0 if successful
 ******************************************************************/
int sliderender_set_slide(sliderender_t *render, int slidenumber)
{
    slidedeck_t *deck = render->deck;
    if (slidenumber >= deck->nslides || slidenumber < 0)
        return 1; /* Invalid slide number */

    sliderender_clear(render);
    render->slide = deck->slides[slidenumber];

    /* Prepare the families */
    render->family_body = sliderender_prepare_font(render, "body", &fontdefault_body);
    if (!render->family_body)
    {
        dprintf("Cannot initialise the font family for body\n");
        goto failed;
    }

    render->family_code = sliderender_prepare_font(render, "code", &fontdefault_code);
    if (!render->family_code)
    {
        dprintf("Cannot initialise the font family for code\n");
        goto failed;
    }
    {
        char name[4];
        int n;
        for (n=0; n<MAXHEADING; n++)
        {
            sprintf(name, "h%i", n + 1);
            render->family_heading[n] = sliderender_prepare_font(render, name, &fontdefault_headings[n]);
            if (!render->family_heading[n])
            {
                dprintf("Cannot initialise the font family for heading %i\n", n+1);
                goto failed;
            }
        }
    }

    render->font_body = fontfamily_get_font(render->family_body, FONTFAMILY_STYLE_BASE);
    if (!render->font_body)
    {
        dprintf("Cannot initialise the font family for body\n");
        goto failed;
    }

    render->em = text_getemsize(render->font_body);

    render->colour_bg = 0x00000000;
    render->colour_fg = 0xFFFFFF00;

    return 0;

failed:
    sliderender_clear(render);
    render->slidenumber = -1;
    return 1;
}


/*************************************************** Gerph *********
 Function:      sliderender_show
 Description:   Render the actual slide to the screen
 Parameters:    render-> the render we're going to use.
 Returns:       1 if failed, 0 if successful
 ******************************************************************/
int sliderender_show(sliderender_t *render, int slidenumber)
{
    int inset_x = 64;
    int inset_y = 64;
    int pass;
    if (render == NULL)
        return 1;

    if (!render->textblock)
    {
        render->textblock = textblock_create(render->region.x0 + inset_x, render->region.x0 + inset_y,
                                             render->region.x1 - inset_x, render->region.y1 - inset_y,
                                             TBCREATE_SPACING_150);
    }
    else
    {
        textblock_clear(render->textblock, TBCLEAR_ALL);
    }

    render->in_heading = -1; /* Not in a heading right now */

    for (pass=0; pass<2; pass++)
    {
        slideblock_t *block;
        render->pass = pass;
        if (pass == 1)
        {
            /* The redraw pass - fill the background */
            rect_fill(render->colour_bg, render->region.x0, render->region.y0,
                                         render->region.x1, render->region.y1);
        }
        for (block = render->slide->blocks; block; block=block->next)
        {
            sliderender_block(render, block);
        }
        textblock_clear(render->textblock, TBCLEAR_TEXTTOP | TBCLEAR_COVERED);
    }
    return 0;
}
