/*******************************************************************
 * File:        sliderender
 * Purpose:     Render the slides
 * Author:      Gerph
 * Date:        18 Sep 2020
 ******************************************************************/


#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include "swis.h"

#include "gcontext.h"
#include "textblock.h"
#include "fontfamily.h"

#include "slidedeck.h"
#include "slidedeck_debug.h"
#include "sliderender.h"
#include "colours.h"


/* Define this to debug this file */
//#undef DEBUG
//#define DEBUG

#ifdef DEBUG
#define dprintf if (1) _swix(0x104,0), printf
#else
#define dprintf if (0) _swix(0x104,0), printf
#endif


#define MAXHEADING 3


typedef struct fontconfig_s {
    const char *name;
    int xsize, ysize;
} fontconfig_t;

fontconfig_t fontdefault_body = {
    "HirukoPro.Book", (12*16), (12*16)
};
fontconfig_t fontdefault_code = {
    "FairfaxSMHD.Medium", (12*16), (12*16)
};
fontconfig_t fontdefault_headings[MAXHEADING] = {
    {"Optima.Bold", (22*16), (22*16)},
    {"Optima.Bold", (18*16), (18*16)},
    {"Optima.Regular", (16*16), (16*16)},
};


/* Rendering context for a slide */
struct sliderender_s {
    slidedeck_t *deck;
    slide_t *slide;
    int slidenumber;

    bbox_t region;

    unsigned long colour_bg;
    unsigned long colour_fg;

    int in_heading; /* Which heading we're in, or -1 if we're not in a heading */

    fontfamily_t family_heading[MAXHEADING];
    fontfamily_t family_body;
    fontfamily_t family_code;
    int inset_x, inset_y;

    font_t font_body; /* A reference to the base font in family_body */

    textblock_t textblock;
    int pass;

    bounds_t em;
};


/*************************************************** Gerph *********
 Function:      sliderender_block
 Description:   Render a single block from a slide
 Parameters:    render-> the render to use
                block-> the block we're rendering
 Returns:       none
 ******************************************************************/
static void sliderender_block(sliderender_t *render,
                              slideblock_t *block)
{
    unsigned long flags = (render->pass==0) ? 0 : TBADD_PAINT;
    switch (block->blocktype)
    {
        case sbt_heading:
            dprintf("  Heading %i\n", block->index);
            render->in_heading = block->index - 1;
            break;

        case sbt_list:
            if (block->index == -1)
            {
                dprintf("  List unordered\n");
            }
            else
            {
                dprintf("  List ordered, next index %i\n", block->index);
            }

            /* Entering and leaving a list should insert somee extra space */
            textblock_gap(render->textblock, render->em.height / 2, NULL);

            /* Set up the indentation for the block */
            {
                int indent = render->em.width / 2;
                if (block->parent)
                    indent += render->em.width * 1.5;
                textblock_inset(render->textblock, indent, indent);
            }
            break;

        case sbt_item:
            if (block->index == -1)
            {
                dprintf("  Item unordered\n");
                textblock_inset(render->textblock, render->em.width * .5, render->em.width * .5);
                textblock_add(render->textblock,
                              render->font_body,
                              // "\xb7",        // Latin-1 encoding of middot
                              "\xe2\x80\xa2",   // UTF-8 encoding of bullet
                              render->colour_bg, render->colour_fg,
                              flags);
                textblock_inset(render->textblock, render->em.width, render->em.width);
            }
            else
            {
                char buf[4];
                sprintf(buf, "%i.", block->index + 1);
                dprintf("  Item ordered, index %i\n", block->index);
                textblock_add(render->textblock,
                              render->font_body,
                              buf,
                              render->colour_bg, render->colour_fg,
                              flags);
                // Indent for the spans
                textblock_inset(render->textblock, render->em.width * 1.5, render->em.width * 1.5);
            }

            break;
    }

    /* This is a new horizontal block, so it has its own sizing */
    textblock_clear(render->textblock, TBCLEAR_SIZING);

    if (block->blocks)
    {
        /* Has nested blocks */
        slideblock_t *nest;

        for (nest = block->blocks; nest; nest=nest->next)
        {
            sliderender_block(render, nest);
        }
    }
    if (block->spans)
    {
        slidespan_t *span;
        for (span = block->spans; span; span=span->next)
        {
            int fontstyle = 0;
            int fontflags = flags;
            fontfamily_t family;
            font_t font;
            if (span->render.bold)
                fontstyle |= FONTFAMILY_STYLE_BOLD;
            if (span->render.italic)
                fontstyle |= FONTFAMILY_STYLE_SLANT;
            if (span->render.underline)
                fontflags |= TBADD_UNDERLINE;
            if (span->render.del)
                fontflags |= TBADD_STRIKETHROUGH;

            if (span->render.code)
                family = render->family_code;
            else if (render->in_heading != -1)
                family = render->family_heading[render->in_heading];
            else
                family = render->family_body;

            dprintf("Rendering with family %p\n", family);
            font = fontfamily_get_font(family, fontstyle);

            dprintf("Text: (style=%i) %s\n", fontstyle, span->text);
            textblock_add(render->textblock,
                          font,
                          span->text,
                          render->colour_bg, render->colour_fg,
                          fontflags);
        }

        textblock_clear(render->textblock, TBCLEAR_TEXTNEWLINE);
    }

    switch (block->blocktype)
    {
        case sbt_list:
            /* We're now leaving the list */
            {
                int indent = render->em.width / 2;
                if (block->parent)
                    indent += render->em.width * 1.5;
                textblock_inset(render->textblock, -indent, -indent);
            }

            /* Entering and leaving a list should insert somee extra space */
            textblock_gap(render->textblock, render->em.height / 2, NULL);
            break;

        case sbt_item:
            // Restore the indent as we leave the item
            textblock_inset(render->textblock, -render->em.width * 1.5, -render->em.width * 1.5);
            break;
    }

    /* We're not in a heading any more */
    render->in_heading = -1;
}


/*************************************************** Gerph *********
 Function:      sliderender_fontsize
 Description:   Get the size of a font from a specification string
 Parameters:    render-> the render to work with
                string-> the string to parse
 Returns:       font size in points * 16, or -1 if failed to parse
 ******************************************************************/
static int sliderender_fontsize(sliderender_t *render,
                                const char *string,
                                int is_x)
{
    const char *end;
    char copy[16];
    int multiplier = 1;
    double num;
    /* We need to copy the string as otherwise a value like '1em' won't be able to be
     * parsed, as it looks like an exponentiated number.
     */
    if (strlen(string) > 14)
        return -1; /* Unlikely to be a useful string */

    {
        char *term = &copy[0];
        strcpy(copy, string);
        while ((*term >= '0' && *term <= '9') || *term == '.')
            term++;
        *term = '\0';
        num = strtod(copy, (char**)&end);
        end = (const char *)(string + (term - &copy[0]));
    }

    /* Skip spaces */
    while (*end == ' ')
        end++;

    if (strcmp(end, "pt")==0)
    {
        end += 2, multiplier = 16;
    }
    else if (strcmp(end, "in")==0)
    {
        end += 2, multiplier = 16 * 72;
    }
    else if (strcmp(end, "cm")==0)
    {
        end += 2, multiplier = 16 * 28.3125;
    }
    else if (strcmp(end, "pc")==0)
    {
        end += 2, multiplier = 16 * 12; /* picas */
    }
    else if (strcmp(end, "em")==0)
    {
        end += 2;
        if (is_x)
            multiplier = fontfamily_get_size(render->family_body, FONTFAMILY_STYLE_BASE).width;
        else
            multiplier = fontfamily_get_size(render->family_body, FONTFAMILY_STYLE_BASE).height;
    }
    else
    {
        /* Assume they meant OS units */
        multiplier = 16;
    }

    if (*end != '\0')
    {
        /* Didn't end after the size specification */
        return -1;
    }
    //dprintf("(fontsize: num=%f, multiplier=%i)\n", num, multiplier);
    return (int)(num * multiplier);
}


/*************************************************** Gerph *********
 Function:      sliderender_ossize
 Description:   Get the size of in OS units from a specification string
 Parameters:    render-> the render to work with
                string-> the string to parse
 Returns:       font size in points * 16, or -1 if failed to parse
 ******************************************************************/
static int sliderender_ossize(sliderender_t *render,
                              const char *string,
                              int is_x)
{
    const char *end;
    char copy[16];
    int multiplier = 1;
    double num;
    /* We need to copy the string as otherwise a value like '1em' won't be able to be
     * parsed, as it looks like an exponentiated number.
     */
    if (strlen(string) > 14)
        return -1; /* Unlikely to be a useful string */

    {
        char *term = &copy[0];
        strcpy(copy, string);
        while ((*term >= '0' && *term <= '9') || *term == '.')
            term++;
        *term = '\0';
        num = strtod(copy, (char**)&end);
        end = (const char *)(string + (term - &copy[0]));
    }

    if (end == string)
    {
        /* Didn't parse at all */
        return -1;
    }

    /* Skip spaces */
    while (*end == ' ')
        end++;

    if (strcmp(end, "pt")==0)
    {
        end += 2, multiplier = 2;
    }
    else if (strcmp(end, "in")==0)
    {
        end += 2, multiplier = 2 * 72;
    }
    else if (strcmp(end, "cm")==0)
    {
        end += 2, multiplier = 2 * 28.3125;
    }
    else if (strcmp(end, "pc")==0)
    {
        end += 2, multiplier = 2 * 12; /* picas */
    }
    else if (strcmp(end, "em")==0)
    {
        end += 2;
        if (is_x)
            multiplier = fontfamily_get_size(render->family_body, FONTFAMILY_STYLE_BASE).width / 8;
        else
            multiplier = fontfamily_get_size(render->family_body, FONTFAMILY_STYLE_BASE).height / 8;
    }
    else if (strcmp(end, "px")==0)
    {
        /* Assume they meant OS units */
        end += 2;
        multiplier = 2;
    }

    if (*end != '\0')
    {
        /* Didn't end after the size specification */
        printf("Didn't parse at end: %s\n", end);
        return -1;
    }
    //dprintf("(fontsize: num=%f, multiplier=%i)\n", num, multiplier);
    return (int)(num * multiplier);
}



/*************************************************** Gerph *********
 Function:      sliderender_get_font_config
 Description:   Get the font settings to use for the current slide,
                using the properties from the slide.
 Parameters:    render-> the render to use
                fontkeyname-> the name of the key to use for this family
                stylesuffix-> the suffix to use, prefixed by '.', or NULL
                              for no suffix
                fontdefault-> the defaults to use if not set
 Returns:       none
 ******************************************************************/
static fontconfig_t sliderender_get_font_config(sliderender_t *render,
                                                const char *familykeyname,
                                                const char *stylesuffix,
                                                fontconfig_t *fontdefault)
{
    char property_name[64];
    const char *property_value;
    fontconfig_t config = *fontdefault;
    int size;

    if (stylesuffix == NULL)
        stylesuffix = "";

    // Read the properties for the base of the font
    sprintf(property_name, "%s%s.font", familykeyname, stylesuffix);
    config.name = slide_getproperty(render->slide, property_name, config.name);

    sprintf(property_name, "%s%s.size", familykeyname, stylesuffix);
    property_value = slide_getproperty(render->slide, property_name, NULL);
    if (property_value)
    {
        dprintf("Property for %s defines size as %s\n", property_name, property_value);
        size = sliderender_fontsize(render, property_value, 1);
        if (size != -1)
            config.xsize = size;
        size = sliderender_fontsize(render, property_value, 0);
        if (size != -1)
            config.ysize = size;
        dprintf("  sizes = %i x %i\n", config.xsize, config.ysize);
    }

    sprintf(property_name, "%s%s.height", familykeyname, stylesuffix);
    property_value = slide_getproperty(render->slide, property_name, NULL);
    if (property_value)
    {
        dprintf("Property for %s defines height as %s\n", property_name, property_value);
        size = sliderender_fontsize(render, property_value, 0);
        if (size != -1)
            config.ysize = size;
        dprintf("  height = %i\n", config.ysize);
    }
    return config;
}

/*************************************************** Gerph *********
 Function:      sliderender_prepare_family
 Description:   Set up a font family for the current slide
 Parameters:    render-> the render to work with
                keyname-> the name of this family to set up from the slide properties
                fontdefault-> the defaults to use for this family
 Returns:       fontfamily_t for this font, or NULL if none could be assigned
 ******************************************************************/
static fontfamily_t sliderender_prepare_family(sliderender_t *render,
                                               const char *keyname,
                                               fontconfig_t *fontdefault)
{
    fontfamily_t family;
    fontconfig_t config;
    fontconfig_t baseconfig;

    baseconfig = sliderender_get_font_config(render, keyname, NULL, fontdefault);

    dprintf("Preparing family '%s' with font '%s'\n", keyname, baseconfig.name);
    family = fontfamily_create(baseconfig.name, baseconfig.xsize, baseconfig.ysize);
    if (family == NULL)
    {
        dprintf("Cannot create font family for %s\n", keyname);
        return NULL;
    }

    /* Now populate any of the other fonts */
    config = sliderender_get_font_config(render, keyname, ".italic", &baseconfig);
    /* FIXME: We don't support size yet */
    if (config.name != baseconfig.name)
    {
        dprintf("Override family '%s' italic style: %s\n", keyname, config.name);
        if (fontfamily_set_style(family, FONTFAMILY_STYLE_SLANT, config.name))
        {
            dprintf("Cannot set %s italic style\n", keyname);
            return NULL;
        }
    }

    config = sliderender_get_font_config(render, keyname, ".bold", &baseconfig);
    /* FIXME: We don't support size yet */
    if (config.name != baseconfig.name)
    {
        dprintf("Override family '%s' bold style: %s\n", keyname, config.name);
        if (fontfamily_set_style(family, FONTFAMILY_STYLE_BOLD, config.name))
        {
            dprintf("Cannot set %s bold style\n", keyname);
            return NULL;
        }
    }

    config = sliderender_get_font_config(render, keyname, ".bold.italic", &baseconfig);
    /* FIXME: We don't support size yet */
    if (config.name != baseconfig.name)
    {
        dprintf("Override family '%s' bold italic style: %s\n", keyname, config.name);
        if (fontfamily_set_style(family, FONTFAMILY_STYLE_BOLDSLANT, config.name))
        {
            dprintf("Cannot set %s bold italic style\n", keyname);
            return NULL;
        }
    }

    if (fontfamily_populate(family))
    {
        dprintf("Cannot populate font family for %s\n", keyname);
        return NULL;
    }

    return family;
}


/*************************************************** Gerph *********
 Function:      sliderender_clear
 Description:   Free all the transient and cached details for this render
 Parameters:    render-> the render to clear
 Returns:       none
 ******************************************************************/
static void sliderender_clear(sliderender_t *render)
{
    int n;

    fontfamily_destroy(render->family_body);
    render->family_body = NULL;
    fontfamily_destroy(render->family_code);
    render->family_code = NULL;

    for (n=0; n<MAXHEADING; n++)
    {
        fontfamily_destroy(render->family_heading[n]);
        render->family_heading[n] = NULL;
    }
    textblock_destroy(render->textblock);
    render->textblock = NULL;
}


/*************************************************** Gerph *********
 Function:      sliderender_destroy
 Description:   Destroy the block, freeing all memory associated with it
 Parameters:    render-> the render to free
 Returns:       none
 ******************************************************************/
void sliderender_destroy(sliderender_t *render)
{
    if (render == NULL)
        return;

    sliderender_clear(render);
    free(render);
}


/*************************************************** Gerph *********
 Function:      sliderender_create
 Description:   Create a structure to manage the rendering of the
                slides
 Parameters:    deck-> the slide deck to render
                slidenumber = the number of the slide we're rendering
                region-> the bounds of the region to prepare for
 Returns:       pointer to sliderender_t, or NULL if failed
 ******************************************************************/
sliderender_t *sliderender_create(slidedeck_t *deck, int slidenumber, bbox_t *region)
{
    sliderender_t *render = calloc(1, sizeof(*render));
    if (render == NULL)
        return NULL;

    render->deck = deck;
    render->slidenumber = -1;
    if (region)
    {
        render->region = *region;
    }
    else
    {
        /* If no region was specified, give it a default size; they can change it later */
        render->region.x0 = 0;
        render->region.y0 = 0;
        render->region.x1 = 640;
        render->region.y1 = 480;
    }

    if (sliderender_set_slide(render, slidenumber))
    {
        /* Select the slide failed. */
        render->slidenumber = -1;
    }

    return render;
}


/*************************************************** Gerph *********
 Function:      sliderender_set_slide
 Description:   Select the slide number that we are going to render
 Parameters:    render-> the render block
                slidenumber = number of the slide we're going to show
 Returns:       1 if failed, 0 if successful
 ******************************************************************/
int sliderender_set_slide(sliderender_t *render, int slidenumber)
{
    slidedeck_t *deck = render->deck;
    if (slidenumber >= deck->nslides || slidenumber < 0)
        return 1; /* Invalid slide number */

    sliderender_clear(render);
    render->slide = deck->slides[slidenumber];

    /* Prepare the families */
    render->family_body = sliderender_prepare_family(render, "body", &fontdefault_body);
    if (!render->family_body)
    {
        dprintf("Cannot initialise the font family for body\n");
        goto failed;
    }

    render->family_code = sliderender_prepare_family(render, "code", &fontdefault_code);
    if (!render->family_code)
    {
        dprintf("Cannot initialise the font family for code\n");
        goto failed;
    }
    {
        char name[4];
        int n;
        for (n=0; n<MAXHEADING; n++)
        {
            sprintf(name, "h%i", n + 1);
            render->family_heading[n] = sliderender_prepare_family(render, name, &fontdefault_headings[n]);
            if (!render->family_heading[n])
            {
                dprintf("Cannot initialise the font family for heading %i\n", n+1);
                goto failed;
            }
        }
    }

    render->font_body = fontfamily_get_font(render->family_body, FONTFAMILY_STYLE_BASE);
    if (!render->font_body)
    {
        dprintf("Cannot initialise the font family for body\n");
        goto failed;
    }

    render->em = text_getemsize(render->font_body);

    {
        const char *colspec;
        rgb_t col;

        colspec = slide_getproperty(render->slide, "background-colour", "black");
        col = colours_parse(colspec, -1);
        render->colour_bg = (col==-1) ? 0x00000000 : col;

        colspec = slide_getproperty(render->slide, "foreground-colour", "white");
        col = colours_parse(colspec, -1);
        render->colour_fg = (col==-1) ? 0xFFFFFF00 : col;
    }

    {
        int inset_x = 0;
        int inset_y = 0;
        const char *padding = slide_getproperty(render->slide, "padding", NULL);
        if (padding)
        {
            inset_x = sliderender_ossize(render, padding, 1);
            inset_y = sliderender_ossize(render, padding, 0);
        }
        else
        {
            padding = slide_getproperty(render->slide, "padding-horizontal", "16px");
            inset_x = sliderender_ossize(render, padding, 1);

            padding = slide_getproperty(render->slide, "padding-vertical", "16px");
            inset_y = sliderender_ossize(render, padding, 0);
        }

        /* FIXME: For now just ignore any invalid values */
        if (inset_x == -1)
            inset_x = 0;
        if (inset_y == -1)
            inset_y = 0;

        render->inset_x = inset_x;
        render->inset_y = inset_y;
        dprintf("inset = %i, %i", inset_x, inset_y);
    }

    return 0;

failed:
    sliderender_clear(render);
    render->slide = NULL;
    render->slidenumber = -1;
    return 1;
}


/*************************************************** Gerph *********
 Function:      sliderender_show
 Description:   Render the actual slide to the screen
 Parameters:    render-> the render we're going to use.
 Returns:       1 if failed, 0 if successful
 ******************************************************************/
int sliderender_show(sliderender_t *render)
{
    int pass;
    int spacer = 0;
    const char *vertical_align;
    if (render == NULL)
        return 1;

    if (render->slide == NULL)
    {
        dprintf("No slide currently selected for render\n");
        return 1;
    }

    if (!render->textblock)
    {
        render->textblock = textblock_create(render->region.x0 + render->inset_x, render->region.y0 + render->inset_y,
                                             render->region.x1 - render->inset_x, render->region.y1 - render->inset_y,
                                             TBCREATE_SPACING_150);
    }
    else
    {
        textblock_clear(render->textblock, TBCLEAR_ALL);
    }

    vertical_align = slide_getproperty(render->slide, "vertical-align", NULL);

    render->in_heading = -1; /* Not in a heading right now */

    for (pass=0; pass<2; pass++)
    {
        slideblock_t *block;
        render->pass = pass;
        if (pass == 1)
        {
            /* The redraw pass - fill the background */
            rect_fill(render->colour_bg, render->region.x0, render->region.y0,
                                         render->region.x1, render->region.y1);
        }

        if (spacer)
            textblock_gap(render->textblock, spacer, NULL);

        for (block = render->slide->blocks; block; block=block->next)
        {
            sliderender_block(render, block);
        }

        if (vertical_align && strcmp(vertical_align, "top") != 0)
        {
            /* Vertical align is set and it's not 'top' */
            int low_y = textblock_extent(render->textblock);
            int remaining_space = low_y - render->region.y0 - render->inset_y;

            /* FIXME: Due to the way that we always add a newline at the end, we will be
             *        one line height out here.
             */

            if (strcmp(vertical_align, "bottom")==0)
            {
                /* Align to the bottom (take 4, so that we don't overrun the end) */
                spacer = remaining_space - 4;
            }
            else if (strcmp(vertical_align, "middle")==0)
            {
                spacer = remaining_space / 2;
            }
        }

        textblock_clear(render->textblock, TBCLEAR_TEXTTOP | TBCLEAR_COVERED);
    }
    return 0;
}
