/*******************************************************************
 * File:        sliderender
 * Purpose:     Render the slides
 * Author:      Gerph
 * Date:        18 Sep 2020
 ******************************************************************/

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include "swis.h"

#ifdef FORTIFY
#include "fortify.h"
#endif

#include "gcontext.h"
#include "textblock.h"
#include "fontfamily.h"

#include "slidedeck.h"
#include "slidedeck_debug.h"
#include "sliderender.h"
#include "position.h"
#include "colours.h"
#include "border.h"
#include "image.h"
#include "str.h"


/* Define this to debug this file */
//#undef DEBUG
//#define DEBUG

#ifdef DEBUG
#define dprintf if (1) _swix(0x104,0), printf
#else
#define dprintf if (0) _swix(0x104,0), printf
#endif


#define MAXHEADING 3


typedef struct fontconfig_s {
    const char *name;
    int xsize, ysize;
} fontconfig_t;

fontconfig_t fontdefault_body = {
    "HirukoPro.Book", (12*16), (12*16)
};
fontconfig_t fontdefault_code = {
    "FairfaxSMHD.Medium", (12*16), (12*16)
};
fontconfig_t fontdefault_headings[MAXHEADING] = {
    {"Optima.Bold", (22*16), (22*16)},
    {"Optima.Bold", (18*16), (18*16)},
    {"Optima.Regular", (16*16), (16*16)},
};
fontconfig_t fontdefault_marginal = {
    "HirukoPro.Book", (8*16), (8*16)
};


typedef struct staticimage_s {
    const char *name;
    int inset;
    int width;
    int height;
    image_t *data;
} staticimage_t;


typedef struct borderparams_s {
    int inset;
    int border_type;
    int border_size;
    int padding;
    rgb_t fill;
    rgb_t border_fore;
    rgb_t border_opp;
} borderparams_t;


typedef struct borderdefaults_s {
    const char *inset;
    const char *padding;
    const char *border_type;
    const char *border_width;
    rgb_t fill;
    rgb_t border_fore;
    rgb_t border_opp;
} borderdefaults_t;


typedef struct paddingparams_s {
    int inset;
    int gap_top;
    int gap_bottom;
} paddingparams_t;


typedef struct paddingdefaults_s {
    const char *inset;
    const char *gap_top;
    const char *gap_bottom;
} paddingdefaults_t;


/* Rendering context for a slide */
struct sliderender_s {
    slidedeck_t *deck;
    slide_t *slide;
    int slidenumber;

    bbox_t region;

    unsigned long colour_bg;
    unsigned long colour_fg;

    int in_heading; /* Which heading we're in, or -1 if we're not in a heading */
    int in_pre;     /* If we're in the pre */
    int in_quote;   /* Quote level we're in (0 for none, 1+ for in quotes) */

    fontfamily_t family_heading[MAXHEADING];
    fontfamily_t family_body;
    fontfamily_t family_code;
    fontfamily_t family_marginal;

    /* Size configurations for the slide */
    int inset_x, inset_y;

    /* Configurations for blocks */
    paddingparams_t heading_padding[MAXHEADING];
    paddingparams_t list_padding;
    paddingparams_t quote_padding;
    paddingparams_t item_padding;
    int item_text_offset;
    int pre_inset;
    int pre_border_type;
    int pre_border_size;
    int pre_padding;
    rgb_t pre_fill;
    rgb_t pre_border_fore;
    rgb_t pre_border_opp;

    positionid_t slidenumber_position;
    int slidenumber_padding;
    const char *slidenumber_format;

    font_t font_body; /* A reference to the base font in family_body */

    /* Image configuration - one for each position tl, tc, tr, cl, cc, cr, bl, bc, br */
    staticimage_t images[9];

    textblock_t textblock;
    int pass;

    bounds_t em;
};


/* Flags to use to get the sizes for sliderender_ossize functions for the relative sizes */
#define OSSIZE_IS_X         (1lu<<0) /* The measure is in the x-dimension */
#define OSSIZE_IS_Y         (0lu<<0) /* The measure is in the y-dimension */
#define OSSIZE_IS_SLIDE     (1lu<<1) /* The measure is relative to the slide dimentions */
#define OSSIZE_IS_SPACE     (0lu<<1) /* The measure is relative to the space remaining */

/*************************************************** Gerph *********
 Function:      sliderender_ossize
 Description:   Get the size of in OS units from a specification string
 Parameters:    render-> the render to work with
                string-> the string to parse
                flags = the OSSIZE_* flags for parsing the string
 Returns:       font size in points * 16, or -1 if failed to parse
 ******************************************************************/
static int sliderender_ossize(sliderender_t *render,
                              const char *string,
                              unsigned long flags)
{
    const char *end;
    char copy[16];
    int multiplier = 1;
    double num;
    /* We need to copy the string as otherwise a value like '1em' won't be able to be
     * parsed, as it looks like an exponentiated number.
     */
    if (strlen(string) > 14)
        return -1; /* Unlikely to be a useful string */

    {
        char *term = &copy[0];
        strcpy(copy, string);
        while ((*term >= '0' && *term <= '9') || *term == '.')
            term++;
        *term = '\0';
        num = strtod(copy, (char**)&end);
        end = (const char *)(string + (term - &copy[0]));
    }

    if (end == string)
    {
        /* Didn't parse at all */
        return -1;
    }

    /* Skip spaces */
    while (*end == ' ')
        end++;

    if (strcmp(end, "pt")==0)
    {
        end += 2, multiplier = 2;
    }
    else if (strcmp(end, "in")==0)
    {
        end += 2, multiplier = 2 * 72;
    }
    else if (strcmp(end, "cm")==0)
    {
        end += 2, multiplier = 2 * 28.3125;
    }
    else if (strcmp(end, "pc")==0)
    {
        end += 2, multiplier = 2 * 12; /* picas */
    }
    else if (strcmp(end, "em")==0)
    {
        end += 2;
        if (flags & OSSIZE_IS_X)
            multiplier = fontfamily_get_size(render->family_body, FONTFAMILY_STYLE_BASE).width / 8;
        else
            multiplier = fontfamily_get_size(render->family_body, FONTFAMILY_STYLE_BASE).height / 8;
    }
    else if (strcmp(end, "px")==0)
    {
        /* Although they said PX they meant the common pixel size (an EX0 EY0 mode will be have same scale) */
        end += 2;
        multiplier = 2;
    }
    else if (strcmp(end, "%")==0)
    {
        /* Portion of the slide or the remaining region */
        int limit;
        if (flags & OSSIZE_IS_SLIDE)
        {
            /* Portion of the slide */
            if (flags & OSSIZE_IS_X)
                limit = render->region.x1 - render->region.x0;
            else
                limit = render->region.y1 - render->region.y0;
        }
        else
        {
            /* Remaining space in the block */
            bbox_t bbox;
            textblock_region(render->textblock, &bbox,
                             TBREGION_WHERE_REMAINING | TBREGION_INSET | TBREGION_POSITION);
            if (flags & OSSIZE_IS_X)
                limit = bbox.x1 - bbox.x0;
            else
                limit = bbox.y1 - bbox.y0;
        }
        if (num < 0)
            num = 0;
        if (num > 100)
            num = 100;
        num = num * limit / 100.0;
        end += 1;
    }

    if (*end != '\0')
    {
        /* Didn't end after the size specification */
        printf("Didn't parse at end: %s\n", end);
        return -1;
    }
    //dprintf("(fontsize: num=%f, multiplier=%i)\n", num, multiplier);
    return (int)(num * multiplier);
}

/*************************************************** Gerph *********
 Function:      sliderender_span_property_osunit
 Description:   Read the property for a given image span as OS Units
 Parameters:    render-> the render block to read
                property-> the name of the property

                default_size = the default size specification as a string
                flags = OSSIZE_* flags for the scaling
 Returns:       size in os units
 ******************************************************************/
static int sliderender_span_property_osunit(sliderender_t *render, slidespan_t *span,
                                            const char *property,
                                            const char *default_size,
                                            unsigned long flags)
{
    const char *value;
    int size;

    value = slidespan_image_getproperty(span, property, default_size);
    if (value == NULL)
    {
        /* This span isn't an image... we'll just return the default size */
        value = default_size;
    }
    size = sliderender_ossize(render, value, flags);

    return size;
}

/*************************************************** Gerph *********
 Function:      sliderender_slide_property_osunit
 Description:   Read the property for a given slide as OS Units
 Parameters:    render-> the render block to read
                property-> the name of the property
                default_size = the default size specification as a string
                flags = OSSIZE_* flags for the scaling
 Returns:       size in os units
 ******************************************************************/
static int sliderender_slide_property_osunit(sliderender_t *render, const char *property,
                                             const char *default_size,
                                             unsigned long flags)
{
    const char *value;
    int size;

    value = slide_getproperty(render->slide, property, default_size);
    size = sliderender_ossize(render, value, flags);

    return size;
}


/*************************************************** Gerph *********
 Function:      sliderender_slide_property_border
 Description:   Read the property for a given slide as a border type
 Parameters:    render-> the render block to read
                property-> the name of the property
                default_type = the default border specification as a string
 Returns:       border type number, or 0 if unrecognised
 ******************************************************************/
static int sliderender_slide_property_border(sliderender_t *render, const char *property,
                                             const char *default_border)
{
    static const char *border_type_names[] = {
            "none",
            "solid",
            "double",
            "sunk",
            "raised",
            "ridge",
            "groove",
        };
#define BORDER_TYPE_COUNT (sizeof(border_type_names) / sizeof(border_type_names[0]))
    const char *value;
    int type;

    value = slide_getproperty(render->slide, property, default_border);

    for (type=0; type < BORDER_TYPE_COUNT; type++)
    {
        if (strcmp(border_type_names[type], value) == 0)
        {
            return type;
        }
    }

    /* Unrecognised types */
    return 0;
}


/*************************************************** Gerph *********
 Function:      sliderender_slide_property_rgb
 Description:   Read the property for a given slide as a colour
 Parameters:    render-> the render block to read
                property-> the name of the property
                default_colour = the default colour as an RGB value
                allow_none = 1 if 'none' should be allowed
 Returns:       rgb_t colour value
 ******************************************************************/
static rgb_t sliderender_slide_property_rgb(sliderender_t *render,
                                            const char *property,
                                            rgb_t default_colour,
                                            int allow_none)
{
    const char *value;
    rgb_t colour = default_colour;
    value = slide_getproperty(render->slide, property, NULL);
    if (value)
    {
        if (allow_none)
        {
            if (strcmp(value, "none")==0)
                return COLOUR_NONE;
        }
        colour = colours_parse(value, -1);
        if (colour == -1)
            colour = default_colour;
    }
    return colour;
}


/*************************************************** Gerph *********
 Function:      sliderender_span_text
 Description:   Render the content of a single span of text within a block
 Parameters:    render-> the sliderender we're in
                block-> the slideblock we're in
                span-> the text span to render
                flags = the base flags (specifically TBADD_PAINT if we should plot)
 Returns:       none
 ******************************************************************/
static void sliderender_span_text(sliderender_t *render,
                                  slideblock_t *block,
                                  slidespan_t *span,
                                  unsigned long flags)
{
    int fontstyle = 0;
    int fontflags = flags;
    fontfamily_t family;
    font_t font;

    if (strcmp(span->data.text.text, "\n")==0)
    {
        /* Special case of a plain newline as the only part of the span - means an actual newline */

        /* Inside a pre, it's always a newline; elsewhere, just make sure we're on a new line */
        if (render->in_pre)
            textblock_newline(render->textblock);
        else
            textblock_clear(render->textblock, TBCLEAR_TEXTNEWLINE);
        return;
    }

    if (span->data.text.render.bold)
        fontstyle |= FONTFAMILY_STYLE_BOLD;
    if (span->data.text.render.italic)
        fontstyle |= FONTFAMILY_STYLE_SLANT;
    if (span->data.text.render.underline)
        fontflags |= TBADD_UNDERLINE;
    if (span->data.text.render.del)
        fontflags |= TBADD_STRIKETHROUGH;

    if (span->data.text.render.code || render->in_pre)
        family = render->family_code;
    else if (render->in_heading != -1)
        family = render->family_heading[render->in_heading];
    else
        family = render->family_body;

    dprintf("Rendering with family %p\n", family);
    font = fontfamily_get_font(family, fontstyle);

    dprintf("Text: (style=%i) %s\n", fontstyle, span->data.text.text);
    textblock_add(render->textblock,
                  font,
                  span->data.text.text,
                  render->colour_bg, render->colour_fg,
                  fontflags);
}


/*************************************************** Gerph *********
 Function:      sliderender_span_image_find
 Description:   Find an image for a span
 Parameters:    render-> the sliderender we're in
                block-> the slideblock we're in
                span-> the image span to render
 Returns:       pointer to an image_t for the image, or None if failed
 ******************************************************************/
static image_t *sliderender_span_image_find(sliderender_t *render,
                                            slideblock_t *block,
                                            slidespan_t *span)
{
    /* FIXME: Update this to be a lookup in the imagelist */
    const char *filename;
    image_t *image = image_create(span->data.image.name);
    if (image == NULL)
        return NULL;

    /* FIXME: Perform resolution on the image name, if necessary */
    filename = span->data.image.name;
    if (image_loadfile(image, filename))
    {
        image_destroy(image);
        return NULL;
    }

    return image;
}


/*************************************************** Gerph *********
 Function:      sliderender_span_image_release
 Description:   Release an image we found for a span
 Parameters:    render-> the sliderender we're in
                block-> the slideblock we're in
                span-> the image span to render
                image-> the image to release
 Returns:       pointer to an image_t for the image, or None if failed
 ******************************************************************/
static void sliderender_span_image_release(sliderender_t *render,
                                           slideblock_t *block,
                                           slidespan_t *span,
                                           image_t *image)
{
    /* FIXME: Update this to be a release from the imagelist */
    if (!image)
        return;

    image_destroy(image);
}

/*************************************************** Gerph *********
 Function:      sliderender_span_image
 Description:   Render the content of a single image span within a block
 Parameters:    render-> the sliderender we're in
                block-> the slideblock we're in
                span-> the image span to render
                flags = the base flags (specifically TBADD_PAINT if we should plot)
 Returns:       none
 ******************************************************************/
static void sliderender_span_image(sliderender_t *render,
                                   slideblock_t *block,
                                   slidespan_t *span,
                                   unsigned long flags)
{
    image_t *image = NULL;
    int width = -1;
    int height = -1;

    /* Work out the properties for this image */
    width = sliderender_span_property_osunit(render, span, "width", "0", OSSIZE_IS_X | OSSIZE_IS_SPACE);
    height = sliderender_span_property_osunit(render, span, "height", "0", OSSIZE_IS_Y | OSSIZE_IS_SPACE);
    if (width == -1 || height == -1)
    {
        dprintf("Could not parse the span image properties for height/width\n");
        return;
    }


    /* FIXME This is inefficient - we have to load the named image on each call;
     * using an image list may help, but we're still going to have to get box sizes. */

    if (image == NULL && (width == 0 || height == 0 || (flags & TBADD_PAINT)))
    {
        image = sliderender_span_image_find(render, block, span);
        if (image == NULL)
        {
            dprintf("Failed to find span image '%s'\n", span->data.image.name);
            return;
        }
    }

    /* A value of 0 means to use the image's natural size */
    if (width == 0 || height == 0)
    {
        bbox_t bbox;

        if (image_bbox(image, &bbox))
        {
            dprintf("Failed to get bbox for span image '%s'\n", span->data.image.name);
            sliderender_span_image_release(render, block, span, image);
            return;
        }

        if (width == 0)
            width = bbox.x1 - bbox.x0;
        if (height == 0)
            height = bbox.y1 - bbox.y0;
    }
    dprintf("Image bbox: %i x %i\n", width, height);

    /* Make space for the image */
    {
        bbox_t bbox;
        if (!textblock_space(render->textblock, width, height, &bbox))
        {
            dprintf("Textblock could not fit the image in\n");
        }
        else
        {
            dprintf("Image bbox: %i x %i\n", width, height);

            if (flags & TBADD_PAINT)
            {
                int border = 0;
                /* rect_fill(0xcccccc00, bbox.x0, bbox.y0, bbox.x1, bbox.y1); */

                image_render_tofit(image, &bbox, border);
            }
        }
    }

    /* Release any image we claimed */
    sliderender_span_image_release(render, block, span, image);
}


/*************************************************** Gerph *********
 Function:      sliderender_block
 Description:   Render a single block from a slide
 Parameters:    render-> the render to use
                block-> the block we're rendering
 Returns:       none
 ******************************************************************/
static void sliderender_block(sliderender_t *render,
                              slideblock_t *block)
{
    unsigned long flags = (render->pass==0) ? 0 : TBADD_PAINT;
    switch (block->blocktype)
    {
        case sbt_heading:
            dprintf("  Heading %i\n", block->index);
            render->in_heading = block->index - 1;

            /* Padding for the headings */
            {
                paddingparams_t *padding = &render->heading_padding[render->in_heading];
                textblock_gap(render->textblock, padding->gap_top, NULL);
                textblock_inset(render->textblock, padding->inset, padding->inset);
            }
            break;

        case sbt_list:
            if (block->index == -1)
            {
                dprintf("  List unordered\n");
            }
            else
            {
                dprintf("  List ordered, next index %i\n", block->index);
            }

            /* Entering and leaving a list should insert some extra space */
            textblock_gap(render->textblock, render->list_padding.gap_top, NULL);

            /* Set up the indentation for the block */
            {
                int indent = render->list_padding.inset;
                if (block->parent)
                    indent += render->item_text_offset;
                textblock_inset(render->textblock, indent, indent);
            }
            break;

        case sbt_item:
            textblock_gap(render->textblock, render->item_padding.gap_top, NULL);

            /* FIXME: This isn't right; it means that we'll add the text blocks using the size of the
             *        lines in the prior block, which won't come out right if the lines change in size.
             *        For my purposes I think this is not a problem, but it might need to be fixed in
             *        future - it should be moved to happen inside start of the span rendering.
             */
            if (block->index == -1)
            {
                dprintf("  Item unordered\n");
                textblock_inset(render->textblock, render->item_padding.inset, render->item_padding.inset);
                textblock_add(render->textblock,
                              render->font_body,
                              // "\xb7",        // Latin-1 encoding of middot
                              "\xe2\x80\xa2",   // UTF-8 encoding of bullet
                              render->colour_bg, render->colour_fg,
                              flags);
                textblock_inset(render->textblock, render->item_text_offset, render->item_text_offset);
            }
            else
            {
                char buf[4];
                sprintf(buf, "%i.", block->index + 1);
                dprintf("  Item ordered, index %i\n", block->index);
                textblock_add(render->textblock,
                              render->font_body,
                              buf,
                              render->colour_bg, render->colour_fg,
                              flags);
                // Indent for the spans
                textblock_inset(render->textblock, render->item_padding.inset + render->item_text_offset,
                                                   render->item_padding.inset + render->item_text_offset);
            }

            break;

        case sbt_pre:
            textblock_inset(render->textblock, render->pre_inset, render->pre_inset);
            render->in_pre = 1;
            break;

        case sbt_quote:
            /* Entering and leaving a quote should insert somee extra space */
            textblock_gap(render->textblock, render->quote_padding.gap_top, NULL);

            textblock_inset(render->textblock, render->quote_padding.inset, render->quote_padding.inset);
            render->in_quote = block->index + 1;
            break;
    }

    /* This is a new horizontal block, so it has its own sizing */
    textblock_clear(render->textblock, TBCLEAR_SIZING);

    if (block->blocks)
    {
        /* Has nested blocks */
        slideblock_t *nest;

        for (nest = block->blocks; nest; nest=nest->next)
        {
            sliderender_block(render, nest);
        }
    }
    if (block->spans)
    {
        slidespan_t *span;
        int span_pass;
        bbox_t extent;
        textblock_mark(render->textblock);
        for (span_pass = 0; span_pass < 2; span_pass++)
        {
            flags = (render->pass==0 || span_pass == 0) ? 0 : TBADD_PAINT;

            if (render->in_pre)
            {
                if (render->pass && span_pass)
                {
                    /* Draw a background on the region */
                    bbox_t top;
                    rgb_t colour_fore = render->pre_border_fore;
                    rgb_t colour_opp = render->pre_border_opp;
                    textblock_region(render->textblock, &top, TBREGION_WHERE_REMAINING | TBREGION_INSET);

                    if (render->pre_fill != COLOUR_NONE)
                    {
                        rect_fill(render->pre_fill, top.x0, top.y1,
                                                    top.x1, extent.y1);
                    }

                    if (colour_fore == COLOUR_NONE &&
                        colour_opp == COLOUR_NONE)
                    {
                        colour_fore = render->pre_fill; /* Use the automatic selection, based on fill */
                    }

                    border_drawsimple(render->pre_border_type, render->pre_border_size,
                                      top.x0, top.y1, top.x1-top.x0, top.y1 - extent.y1,
                                      colour_fore, colour_opp);
                }
                textblock_gap(render->textblock, render->pre_border_size + render->pre_padding, NULL);
                textblock_inset(render->textblock, (render->pre_border_size + render->pre_padding),
                                                   (render->pre_border_size + render->pre_padding));
            }

            for (span = block->spans; span; span=span->next)
            {
                switch (span->type)
                {
                    case sst_text:
                        sliderender_span_text(render, block, span, flags);
                        break;

                    case sst_image:
                        sliderender_span_image(render, block, span, flags);
                        break;
                }
            }

            if (render->in_pre)
            {
                textblock_inset(render->textblock, -(render->pre_border_size + render->pre_padding),
                                                   -(render->pre_border_size + render->pre_padding));
                textblock_gap(render->textblock, render->pre_border_size + render->pre_padding, NULL);
            }

            textblock_region(render->textblock, &extent, TBREGION_WHERE_REMAINING | TBREGION_INSET);
            if (span_pass == 0)
            {
                textblock_clear(render->textblock, TBCLEAR_TEXTMARK);
            }
        }

        textblock_clear(render->textblock, TBCLEAR_TEXTNEWLINE);
    }

    switch (block->blocktype)
    {
        case sbt_heading:
            /* Padding for the headings */
            {
                paddingparams_t *padding = &render->heading_padding[render->in_heading];
                textblock_gap(render->textblock, padding->gap_bottom, NULL);
                textblock_inset(render->textblock, -padding->inset, -padding->inset);
            }
            break;

        case sbt_list:
            /* We're now leaving the list */
            {
                int indent = render->list_padding.inset;
                if (block->parent)
                    indent += render->item_text_offset;
                textblock_inset(render->textblock, -indent, -indent);
            }

            /* Entering and leaving a list should insert some extra space */
            textblock_gap(render->textblock, render->list_padding.gap_bottom, NULL);
            break;

        case sbt_item:
            // Restore the indent as we leave the item
            textblock_inset(render->textblock, -(render->item_padding.inset + render->item_text_offset),
                                               -(render->item_padding.inset + render->item_text_offset));

            textblock_gap(render->textblock, render->item_padding.gap_bottom, NULL);
            break;

        case sbt_pre:
            textblock_inset(render->textblock, -render->pre_inset, -render->pre_inset);
            render->in_pre = 0;
            break;

        case sbt_quote:
            /* Entering and leaving a list should insert some extra space */
            textblock_gap(render->textblock, render->quote_padding.gap_bottom, NULL);

            textblock_inset(render->textblock, -render->quote_padding.inset, -render->quote_padding.inset);
            render->in_quote = 0;
            break;
    }

    /* We're not in a heading any more */
    render->in_heading = -1;
}


/*************************************************** Gerph *********
 Function:      sliderender_fontsize
 Description:   Get the size of a font from a specification string
 Parameters:    render-> the render to work with
                string-> the string to parse
 Returns:       font size in points * 16, or -1 if failed to parse
 ******************************************************************/
static int sliderender_fontsize(sliderender_t *render,
                                const char *string,
                                int is_x)
{
    const char *end;
    char copy[16];
    int multiplier = 1;
    double num;
    /* We need to copy the string as otherwise a value like '1em' won't be able to be
     * parsed, as it looks like an exponentiated number.
     */
    if (strlen(string) > 14)
        return -1; /* Unlikely to be a useful string */

    {
        char *term = &copy[0];
        strcpy(copy, string);
        while ((*term >= '0' && *term <= '9') || *term == '.')
            term++;
        *term = '\0';
        num = strtod(copy, (char**)&end);
        end = (const char *)(string + (term - &copy[0]));
    }

    /* Skip spaces */
    while (*end == ' ')
        end++;

    if (strcmp(end, "pt")==0)
    {
        end += 2, multiplier = 16;
    }
    else if (strcmp(end, "in")==0)
    {
        end += 2, multiplier = 16 * 72;
    }
    else if (strcmp(end, "cm")==0)
    {
        end += 2, multiplier = 16 * 28.3125;
    }
    else if (strcmp(end, "pc")==0)
    {
        end += 2, multiplier = 16 * 12; /* picas */
    }
    else if (strcmp(end, "em")==0)
    {
        end += 2;
        if (is_x)
            multiplier = fontfamily_get_size(render->family_body, FONTFAMILY_STYLE_BASE).width;
        else
            multiplier = fontfamily_get_size(render->family_body, FONTFAMILY_STYLE_BASE).height;
    }
    else
    {
        /* Assume they meant OS units */
        multiplier = 16;
    }

    if (*end != '\0')
    {
        /* Didn't end after the size specification */
        return -1;
    }
    //dprintf("(fontsize: num=%f, multiplier=%i)\n", num, multiplier);
    return (int)(num * multiplier);
}



/*************************************************** Gerph *********
 Function:      sliderender_get_font_config
 Description:   Get the font settings to use for the current slide,
                using the properties from the slide.
 Parameters:    render-> the render to use
                fontkeyname-> the name of the key to use for this family
                stylesuffix-> the suffix to use, prefixed by '.', or NULL
                              for no suffix
                fontdefault-> the defaults to use if not set
 Returns:       none
 ******************************************************************/
static fontconfig_t sliderender_get_font_config(sliderender_t *render,
                                                const char *familykeyname,
                                                const char *stylesuffix,
                                                fontconfig_t *fontdefault)
{
    char property_name[64];
    const char *property_value;
    fontconfig_t config = *fontdefault;
    int size;

    if (stylesuffix == NULL)
        stylesuffix = "";

    // Read the properties for the base of the font
    sprintf(property_name, "%s%s.font", familykeyname, stylesuffix);
    config.name = slide_getproperty(render->slide, property_name, config.name);

    sprintf(property_name, "%s%s.size", familykeyname, stylesuffix);
    property_value = slide_getproperty(render->slide, property_name, NULL);
    if (property_value)
    {
        dprintf("Property for %s defines size as %s\n", property_name, property_value);
        size = sliderender_fontsize(render, property_value, 1);
        if (size != -1)
            config.xsize = size;
        size = sliderender_fontsize(render, property_value, 0);
        if (size != -1)
            config.ysize = size;
        dprintf("  sizes = %i x %i\n", config.xsize, config.ysize);
    }

    sprintf(property_name, "%s%s.height", familykeyname, stylesuffix);
    property_value = slide_getproperty(render->slide, property_name, NULL);
    if (property_value)
    {
        dprintf("Property for %s defines height as %s\n", property_name, property_value);
        size = sliderender_fontsize(render, property_value, 0);
        if (size != -1)
            config.ysize = size;
        dprintf("  height = %i\n", config.ysize);
    }
    return config;
}

/*************************************************** Gerph *********
 Function:      sliderender_prepare_family
 Description:   Set up a font family for the current slide
 Parameters:    render-> the render to work with
                keyname-> the name of this family to set up from the slide properties
                fontdefault-> the defaults to use for this family
 Returns:       fontfamily_t for this font, or NULL if none could be assigned
 ******************************************************************/
static fontfamily_t sliderender_prepare_family(sliderender_t *render,
                                               const char *keyname,
                                               fontconfig_t *fontdefault)
{
    fontfamily_t family;
    fontconfig_t config;
    fontconfig_t baseconfig;

    baseconfig = sliderender_get_font_config(render, keyname, NULL, fontdefault);

    dprintf("Preparing family '%s' with font '%s'\n", keyname, baseconfig.name);
    family = fontfamily_create(baseconfig.name, baseconfig.xsize, baseconfig.ysize);
    if (family == NULL)
    {
        dprintf("Cannot create font family for %s\n", keyname);
        return NULL;
    }

    /* Now populate any of the other fonts */
    config = sliderender_get_font_config(render, keyname, ".italic", &baseconfig);
    /* FIXME: We don't support size yet */
    if (config.name != baseconfig.name)
    {
        dprintf("Override family '%s' italic style: %s\n", keyname, config.name);
        if (fontfamily_set_style(family, FONTFAMILY_STYLE_SLANT, config.name))
        {
            dprintf("Cannot set %s italic style\n", keyname);
            return NULL;
        }
    }

    config = sliderender_get_font_config(render, keyname, ".bold", &baseconfig);
    /* FIXME: We don't support size yet */
    if (config.name != baseconfig.name)
    {
        dprintf("Override family '%s' bold style: %s\n", keyname, config.name);
        if (fontfamily_set_style(family, FONTFAMILY_STYLE_BOLD, config.name))
        {
            dprintf("Cannot set %s bold style\n", keyname);
            return NULL;
        }
    }

    config = sliderender_get_font_config(render, keyname, ".bold.italic", &baseconfig);
    /* FIXME: We don't support size yet */
    if (config.name != baseconfig.name)
    {
        dprintf("Override family '%s' bold italic style: %s\n", keyname, config.name);
        if (fontfamily_set_style(family, FONTFAMILY_STYLE_BOLDSLANT, config.name))
        {
            dprintf("Cannot set %s bold italic style\n", keyname);
            return NULL;
        }
    }

    if (fontfamily_populate(family))
    {
        dprintf("Cannot populate font family for %s\n", keyname);
        return NULL;
    }

    return family;
}


/*************************************************** Gerph *********
 Function:      sliderender_clear
 Description:   Free all the transient and cached details for this render
 Parameters:    render-> the render to clear
 Returns:       none
 ******************************************************************/
static void sliderender_clear(sliderender_t *render)
{
    int n;

    /* Font families */
    fontfamily_destroy(render->family_body);
    render->family_body = NULL;
    fontfamily_destroy(render->family_code);
    render->family_code = NULL;

    for (n=0; n<MAXHEADING; n++)
    {
        fontfamily_destroy(render->family_heading[n]);
        render->family_heading[n] = NULL;
    }
    fontfamily_destroy(render->family_marginal);
    render->family_marginal = NULL;

    /* Text regions */
    textblock_destroy(render->textblock);
    render->textblock = NULL;

    /* Image patterns */
    for (n=0; n<9; n++)
    {
        staticimage_t *image = &render->images[n];
        free((char*)image->name);
        image->name = NULL;
        image_destroy(image->data);
        image->data = NULL;
    }
}


/*************************************************** Gerph *********
 Function:      sliderender_destroy
 Description:   Destroy the block, freeing all memory associated with it
 Parameters:    render-> the render to free
 Returns:       none
 ******************************************************************/
void sliderender_destroy(sliderender_t *render)
{
    if (render == NULL)
        return;

    sliderender_clear(render);
    free(render);
}


/*************************************************** Gerph *********
 Function:      sliderender_create
 Description:   Create a structure to manage the rendering of the
                slides
 Parameters:    deck-> the slide deck to render
                slidenumber = the number of the slide we're rendering
                region-> the bounds of the region to prepare for
 Returns:       pointer to sliderender_t, or NULL if failed
 ******************************************************************/
sliderender_t *sliderender_create(slidedeck_t *deck, int slidenumber, bbox_t *region)
{
    sliderender_t *render = calloc(1, sizeof(*render));
    if (render == NULL)
        return NULL;

    render->deck = deck;
    render->slidenumber = -1;
    if (region)
    {
        render->region = *region;
    }
    else
    {
        /* If no region was specified, give it a default size; they can change it later */
        render->region.x0 = 0;
        render->region.y0 = 0;
        render->region.x1 = 640;
        render->region.y1 = 480;
    }

    if (sliderender_set_slide(render, slidenumber))
    {
        /* Select the slide failed. */
        render->slidenumber = -1;
    }

    return render;
}


/*************************************************** Gerph *********
 Function:      sliderender_get_region
 Description:   Get the size of the region to use for rendering.
 Parameters:    render-> the renderer to work with
                bbox-> the bbox to fill in
 Returns:       none
 ******************************************************************/
void sliderender_get_region(sliderender_t *render, bbox_t *bbox)
{
    *bbox = render->region;
}


/*************************************************** Gerph *********
 Function:      sliderender_set_region
 Description:   Set the size of the region to use for rendering.
 Parameters:    render-> the renderer to work with
                bbox-> the new bbox to use for the render region
 Returns:       1 if failed, 0 if successful
 ******************************************************************/
int sliderender_set_region(sliderender_t *render, bbox_t *bbox)
{
    if (memcmp(bbox, &render->region, sizeof(*bbox))==0)
        return 0; /* Nothing to do; it's already set */

    /* Update our bounding box */
    render->region = *bbox;

    if (render->slidenumber != -1)
    {
        /* Recalculate the relative sizes */
        int slidenumber = render->slidenumber;

        render->slidenumber = -1; /* Force invalid so that we re-select this slide */
        if (sliderender_set_slide(render, slidenumber))
        {
            /* It failed to select; reset to fake slide */
            render->slidenumber = -1;
            return 1;
        }
    }
    return 0;
}


/*************************************************** Gerph *********
 Function:      sliderender_prepare_background
 Description:   Set up the background images we use for the slide
 Parameters:    render-> the render to work with
 Returns:       1 if failed, 0 if successful
 ******************************************************************/
static int sliderender_prepare_background(sliderender_t *render)
{
    int n;
    for (n=0; n<pos_max; n++)
    {
        staticimage_t *simage = &render->images[n];
        char buffer[32];
        char prefix[32];
        char *posname = position_name[n];
        const char *value;

        sprintf(prefix, "logo.%s", posname);
        value = slide_getproperty(render->slide, prefix, NULL);
        if (value != NULL && *value != '\0')
        {
            /* We have a value set, so we should decide what image to use */
            simage->name = strdup(value);
            if (simage->name == NULL)
            {
                /* FIXME: We don't free the earlier image info */
                return 1;
            }
            sprintf(buffer, "%s.inset", prefix);
            simage->inset = sliderender_slide_property_osunit(render, buffer, "0",
                                                              OSSIZE_IS_X | OSSIZE_IS_SLIDE);
            sprintf(buffer, "%s.width", prefix);
            simage->width = sliderender_slide_property_osunit(render, buffer, "0",
                                                              OSSIZE_IS_X | OSSIZE_IS_SLIDE);
            sprintf(buffer, "%s.height", prefix);
            simage->height = sliderender_slide_property_osunit(render, buffer, "0",
                                                               OSSIZE_IS_Y | OSSIZE_IS_SLIDE);
        }
    }

    return 0;
}


/*************************************************** Gerph *********
 Function:      sliderender_slide_property_borderparams
 Description:   Set up properties for a set of border parameters
 Parameters:    render-> the render configuration

 Returns:       1 if failed, 0 if successful
 ******************************************************************/
int sliderender_slide_property_borderparams(sliderender_t *render,
                                            const char *prefix,
                                            borderdefaults_t *defaults,
                                            borderparams_t *params)
{
    char buffer[64];

    sprintf(buffer, "%s.padding.inset", prefix);
    params->inset         = sliderender_slide_property_osunit(render, buffer, defaults->inset, OSSIZE_IS_Y | OSSIZE_IS_SLIDE);

    sprintf(buffer, "%s.border.type", prefix);
    params->border_type   = sliderender_slide_property_border(render, buffer, defaults->border_type);

    sprintf(buffer, "%s.border.width", prefix);
    params->border_size   = sliderender_slide_property_osunit(render, buffer, defaults->border_width, OSSIZE_IS_Y | OSSIZE_IS_SLIDE);

    sprintf(buffer, "%s.padding", prefix);
    params->padding       = sliderender_slide_property_osunit(render, buffer, defaults->padding, OSSIZE_IS_Y | OSSIZE_IS_SLIDE);

    sprintf(buffer, "%s.background-colour", prefix);
    params->fill          = sliderender_slide_property_rgb(render, buffer, defaults->fill, OSSIZE_IS_Y | OSSIZE_IS_SLIDE);

    sprintf(buffer, "%s.border.colour", prefix);
    params->border_fore   = sliderender_slide_property_rgb(render, buffer, defaults->border_fore, OSSIZE_IS_Y | OSSIZE_IS_SLIDE);

    sprintf(buffer, "%s.border.opposite-colour", prefix);
    params->border_opp    = sliderender_slide_property_rgb(render, buffer, defaults->border_opp, 1);

    sprintf(buffer, "%s.border.fore-colour", prefix);
    params->border_fore   = sliderender_slide_property_rgb(render, buffer, defaults->border_fore, 1);

    return 0;
}


/*************************************************** Gerph *********
 Function:      sliderender_slide_property_paddingparams
 Description:   Set up properties for a set of padding parameters
 Parameters:    render-> the render configuration
                prefix-> the string to prefix the property with
                defaults-> the defaults for the properties
                params-> the parameters to fill in
 Returns:       1 if failed, 0 if successful
 ******************************************************************/
int sliderender_slide_property_paddingparams(sliderender_t *render,
                                            const char *prefix,
                                            paddingdefaults_t *defaults,
                                            paddingparams_t *params)
{
    char buffer[64];

    sprintf(buffer, "%s.padding.top", prefix);
    params->gap_top     = sliderender_slide_property_osunit(render, buffer, defaults->gap_top, OSSIZE_IS_X | OSSIZE_IS_SLIDE);

    sprintf(buffer, "%s.padding.bottom", prefix);
    params->gap_bottom  = sliderender_slide_property_osunit(render, buffer, defaults->gap_bottom, OSSIZE_IS_X | OSSIZE_IS_SLIDE);

    sprintf(buffer, "%s.padding.inset", prefix);
    params->inset       = sliderender_slide_property_osunit(render, buffer, defaults->inset, OSSIZE_IS_Y | OSSIZE_IS_SLIDE);

    return 0;
}


/*************************************************** Gerph *********
 Function:      sliderender_set_slide
 Description:   Select the slide number that we are going to render
 Parameters:    render-> the render block
                slidenumber = number of the slide we're going to show
 Returns:       1 if failed, 0 if successful
 ******************************************************************/
int sliderender_set_slide(sliderender_t *render, int slidenumber)
{
    slidedeck_t *deck = render->deck;
    if (slidenumber >= deck->nslides || slidenumber < 0)
        return 1; /* Invalid slide number */

    if (render->slidenumber == slidenumber)
        return 0; /* Slide is already selected */

    sliderender_clear(render);
    render->slide = deck->slides[slidenumber];

    /* Prepare the families */
    render->family_body = sliderender_prepare_family(render, "body", &fontdefault_body);
    if (!render->family_body)
    {
        dprintf("Cannot initialise the font family for body\n");
        goto failed;
    }

    render->family_code = sliderender_prepare_family(render, "code", &fontdefault_code);
    if (!render->family_code)
    {
        dprintf("Cannot initialise the font family for code\n");
        goto failed;
    }
    {
        char name[4];
        int n;
        for (n=0; n<MAXHEADING; n++)
        {
            sprintf(name, "h%i", n + 1);

            /* Font configuration */
            render->family_heading[n] = sliderender_prepare_family(render, name, &fontdefault_headings[n]);
            if (!render->family_heading[n])
            {
                dprintf("Cannot initialise the font family for heading %i\n", n+1);
                goto failed;
            }

            /* Heading padding configuration */
            {
                paddingdefaults_t heading_padding_defaults = {
                    "0em",      // inset,
                    "0em",      // top,
                    "0em",      // bottom,
                };
                sliderender_slide_property_paddingparams(render, name, &heading_padding_defaults, &render->heading_padding[n]);
            }

        }
    }

    render->family_marginal = sliderender_prepare_family(render, "marginal", &fontdefault_marginal);

    render->font_body = fontfamily_get_font(render->family_body, FONTFAMILY_STYLE_BASE);
    if (!render->font_body)
    {
        dprintf("Cannot initialise the font family for body\n");
        goto failed;
    }

    render->em = text_getemsize(render->font_body);

    {
        const char *colspec;
        rgb_t col;

        colspec = slide_getproperty(render->slide, "background-colour", "black");
        col = colours_parse(colspec, -1);
        render->colour_bg = (col==-1) ? 0x00000000 : col;

        colspec = slide_getproperty(render->slide, "foreground-colour", "white");
        col = colours_parse(colspec, -1);
        render->colour_fg = (col==-1) ? 0xFFFFFF00 : col;
    }

    {
        const char *position;
        render->slidenumber_position = pos_invalid;

        position = slide_getproperty(render->slide, "slidenumber.position", NULL);
        if (position && strcmp(position, "none") != 0)
        {
            positionid_t pos = position_parse(position);
            render->slidenumber_position = pos;
            render->slidenumber_padding = sliderender_slide_property_osunit(render, "slidenumber.padding", "1em",
                                                                            OSSIZE_IS_X | OSSIZE_IS_SLIDE);
        }
        render->slidenumber_format = slide_getproperty(render->slide, "slidenumber.format", "$s");
    }

    {
        int inset_x = 0;
        int inset_y = 0;
        const char *padding = slide_getproperty(render->slide, "padding", NULL);
        if (padding)
        {
            inset_x = sliderender_ossize(render, padding, OSSIZE_IS_X | OSSIZE_IS_SLIDE);
            inset_y = sliderender_ossize(render, padding, OSSIZE_IS_Y | OSSIZE_IS_SLIDE);
        }
        else
        {
            inset_x = sliderender_slide_property_osunit(render, "padding-horizontal", "16px",
                                                        OSSIZE_IS_X | OSSIZE_IS_SLIDE);
            inset_y = sliderender_slide_property_osunit(render, "padding-vertical", "16px",
                                                        OSSIZE_IS_Y | OSSIZE_IS_SLIDE);
        }

        /* FIXME: For now just ignore any invalid values */
        if (inset_x == -1)
            inset_x = 0;
        if (inset_y == -1)
            inset_y = 0;

        render->inset_x = inset_x;
        render->inset_y = inset_y;

        /* Size of lists, items, pre code and quote sections */
        {
            paddingdefaults_t list_padding_defaults = {
                "0.5em",    // inset,
                "0.25em",   // top,
                "0.25em",   // bottom,
            };
            sliderender_slide_property_paddingparams(render, "list", &list_padding_defaults, &render->list_padding);
        }
        {
            paddingdefaults_t item_padding_defaults = {
                "0.5em",    // inset,
                "0em",      // top,
                "0em",      // bottom,
            };
            sliderender_slide_property_paddingparams(render, "item", &item_padding_defaults, &render->item_padding);
            render->item_text_offset  = sliderender_slide_property_osunit(render, "item.padding.offset", "1em", OSSIZE_IS_Y | OSSIZE_IS_SLIDE);
        }
        render->pre_inset         = sliderender_slide_property_osunit(render, "pre.padding.inset", "1em", OSSIZE_IS_Y | OSSIZE_IS_SLIDE);
        render->pre_border_type   = sliderender_slide_property_border(render, "pre.border.type", "none");
        render->pre_border_size   = sliderender_slide_property_osunit(render, "pre.border.width", "2px", OSSIZE_IS_Y | OSSIZE_IS_SLIDE);
        render->pre_padding       = sliderender_slide_property_osunit(render, "pre.padding", "0.25em", OSSIZE_IS_Y | OSSIZE_IS_SLIDE);
        render->pre_fill          = sliderender_slide_property_rgb(render, "pre.background-colour", COLOUR_NONE, OSSIZE_IS_Y | OSSIZE_IS_SLIDE);
        render->pre_border_fore   = sliderender_slide_property_rgb(render, "pre.border.colour", COLOUR_NONE, OSSIZE_IS_Y | OSSIZE_IS_SLIDE);
        render->pre_border_opp    = sliderender_slide_property_rgb(render, "pre.border.opposite-colour", render->pre_border_fore, 1);
        render->pre_border_fore   = sliderender_slide_property_rgb(render, "pre.border.fore-colour", render->pre_border_fore, 1);

        {
            paddingdefaults_t quote_padding_defaults = {
                "1.5em",    // inset,
                "1em",      // top,
                "1em",      // bottom,
            };
            sliderender_slide_property_paddingparams(render, "quote", &quote_padding_defaults, &render->quote_padding);
        }

        /* Set up the background */
        sliderender_prepare_background(render);

        dprintf("inset = %i, %i\n", inset_x, inset_y);
    }

    render->slidenumber = slidenumber;
    return 0;

failed:
    sliderender_clear(render);
    render->slide = NULL;
    render->slidenumber = -1;
    return 1;
}


/*************************************************** Gerph *********
 Function:      sliderender_get_slide
 Description:   Read the slide number that we are set for
 Parameters:    render-> the render block
 Returns:       slide number or -1 if invalid
 ******************************************************************/
int sliderender_get_slide(sliderender_t *render)
{
    return render->slidenumber;
}


/*************************************************** Gerph *********
 Function:      sliderender_get_bodyfont
 Description:   Read the body font from the slides
 Parameters:    render-> the render block
 Returns:       font handle
 ******************************************************************/
font_t sliderender_get_bodyfont(sliderender_t *render)
{
    return render->font_body;
}

/*************************************************** Gerph *********
 Function:      sliderender_render_background
 Description:   Render a background for this slide
 Parameters:    render-> the render to work with
 Returns:       1 if failed, 0 if successful
 ******************************************************************/
static int sliderender_render_background(sliderender_t *render)
{
    int n;
    for (n=0; n<9; n++)
    {
        bbox_t bbox;
        staticimage_t *simage = &render->images[n];
        bounds_t size;
        if (simage->name == NULL)
            continue;

        if (simage->data == NULL)
        {
            /* Resolve the image data */
            simage->data = image_create(simage->name);
            if (simage->data == NULL)
            {
                return 1;
            }
            if (image_loadfile(simage->data, simage->name))
            {
                image_destroy(simage->data);
                simage->data = NULL;
                return 1;
            }
        }

        size.width = simage->width;
        size.height = simage->height;

        /* We have the data; now to work out where to put it */
        if (position_calculate(&render->region,
                               &size,
                               0, // no padding
                               n, // positionid
                               &bbox))
        {
            dprintf("Render background failed to find a position\n");
        }
        else
        {
            dprintf("Logo '%s' at %i,%i - %i,%i; inset %i", simage->name, bbox.x0, bbox.y0, bbox.x1, bbox.y1, simage->inset);

            if (image_render_tofit(simage->data, &bbox, simage->inset))
            {
                return 1;
            }
        }
    }
    return 0;
}


/*************************************************** Gerph *********
 Function:      sliderender_format_number
 Description:   Format a string to give us something to use as the slide number
 Parameters:    render-> the render to work with
                format-> the format string:
                            $s = slide number
                            $m = max slide number
 Returns:       1 if failed, 0 if successful
 ******************************************************************/
static char *sliderender_format_number(sliderender_t *render, const char *format)
{
    static char buffer[256]; /* FIXME: Laziness here */
    char *p = buffer;
    while (*format)
    {
        char *esc = strchr(format, '$');
        if (esc == NULL)
        {
            /* No more escape strings, so that's it */
            strcpy(p, format);
            break;
        }

        /* Copy everything up to the escape character */
        memcpy(p, format, esc-format);
        p += (esc-format);

        esc++;
        switch (*esc)
        {
            case 's':
                p += sprintf(p, "%i", render->slidenumber);
                format = esc + 1;
                break;

            case 'm':
                p += sprintf(p, "%i", render->deck->nslides - 1);
                format = esc + 1;
                break;

            case '$':
                *p++ = '$';
                format = esc + 1;
                break;

            default:
                *p++ = '$';
                format = esc;
                break;
        }
    }
    return buffer;
}


/*************************************************** Gerph *********
 Function:      sliderender_render_number
 Description:   Render a slide number for this slide
 Parameters:    render-> the render to work with
 Returns:       1 if failed, 0 if successful
 ******************************************************************/
static int sliderender_render_number(sliderender_t *render)
{
    char *buffer;
    int pass;
    stringbounds_t bounds;
    bbox_t bbox;
    bounds_t size;
    font_t font = fontfamily_get_font(render->family_marginal, FONTFAMILY_STYLE_BASE);

    if (render->slidenumber_position == pos_invalid)
        return 0;

    buffer = sliderender_format_number(render, render->slidenumber_format);
    text_getstringsize(font, &bounds, -1, buffer, -1, 0);

    size.width = bounds.lbearing + bounds.xoffset + bounds.rbearing;
    size.height = bounds.ascent + bounds.descent;

    /* We have the data; now to work out where to put it */
    if (position_calculate(&render->region,
                           &size,
                           render->slidenumber_padding, // no padding
                           render->slidenumber_position, // positionid
                           &bbox))
    {
        dprintf("Slidenumber failed to find a position\n");
    }
    else
    {
        text_paint(font,
                   bbox.x0 + bounds.lbearing, bbox.y0 + bounds.descent,
                   render->colour_bg, render->colour_fg,
                   buffer, -1);
    }
    return 0;
}


/*************************************************** Gerph *********
 Function:      sliderender_show
 Description:   Render the actual slide to the screen
 Parameters:    render-> the render we're going to use.
 Returns:       1 if failed, 0 if successful
 ******************************************************************/
int sliderender_show(sliderender_t *render)
{
    int pass;
    int spacer = 0;
    const char *vertical_align;
    if (render == NULL)
        return 1;

    if (render->slide == NULL)
    {
        dprintf("No slide currently selected for render\n");
        return 1;
    }

    if (!render->textblock)
    {
        /* FIXME: Make spacing a configurable */
        render->textblock = textblock_create(render->region.x0 + render->inset_x, render->region.y0 + render->inset_y,
                                             render->region.x1 - render->inset_x, render->region.y1 - render->inset_y,
                                             TBCREATE_SPACING_120);
    }
    else
    {
        textblock_clear(render->textblock, TBCLEAR_ALL);
    }

    vertical_align = slide_getproperty(render->slide, "vertical-align", NULL);

    render->in_heading = -1; /* Not in a heading right now */
    render->in_pre = 0; /* Not in a pre */

    /* The redraw pass - fill the background */
    rect_fill(render->colour_bg, render->region.x0, render->region.y0,
                                 render->region.x1, render->region.y1);

    /* Draw any background images */
    sliderender_render_background(render);

    /* Draw the slide number */
    sliderender_render_number(render);

    for (pass=0; pass<2; pass++)
    {
        slideblock_t *block;
        render->pass = pass;

        if (spacer)
            textblock_gap(render->textblock, spacer, NULL);

        for (block = render->slide->blocks; block; block=block->next)
        {
            sliderender_block(render, block);
        }

        if (vertical_align && strcmp(vertical_align, "top") != 0)
        {
            /* Vertical align is set and it's not 'top' */
            int low_y = textblock_extent(render->textblock);
            int remaining_space = low_y - render->region.y0 - render->inset_y;

            /* FIXME: Due to the way that we always add a newline at the end, we will be
             *        one line height out here.
             */

            if (strcmp(vertical_align, "bottom")==0)
            {
                /* Align to the bottom (take 4, so that we don't overrun the end) */
                spacer = remaining_space - 4;
            }
            else if (strcmp(vertical_align, "middle")==0)
            {
                spacer = remaining_space / 2;
            }
        }

        textblock_clear(render->textblock, TBCLEAR_TEXTTOP | TBCLEAR_COVERED);
    }
    return 0;
}
